# Java多线程

## 一、基本概念

### 1.同步与异步

同步和异步通常用来形容一次方法调用；

**同步（Synchronous）**：调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。

**异步（Asynchronous）**：调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法会在另一个线程中真实执行。当异步调用需要返回值结果时，在真实调用完成时通知调用者。

### 2. 并发与并行

并发与并行都表示两个或多个任务一起执行；

**并发（ConCurrency）**：侧重多个任务交替执行，而多个任务之间可能是串行的。

**并行（Parallelism）**：多个任务真实同时进行（多核）。

### 3.临界区

临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。

### 4.阻塞与非阻塞

阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是**阻塞**（Blocking）。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。

**非阻塞**（Non-Blocking）的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断前向执行。

### 5.死锁、饥饿锁与活锁

均属于线程活跃性问题；当发生上述情况时，线程可能会不再活跃；

**死锁（Deadlock）**：当一个或多个线程等待系统资源，而资源又被线程本身或其他线程占用时，就形成了死锁；

**饥饿锁（Starvation）**：饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。

**活锁（Livelock）**：由于线程互相谦让而导致资源在线程间跳跃却没有哪个线程真正占有资源而导致线程无法执行的现象。

### 6.并发级别

由于临界区的存在，多线程之间的并发必须受到控制。

**1.阻塞（Blocking）**：一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当我们使用synchronized关键字，或者重入锁时，我们得到的就是阻塞的线程。
无论是synchronized或者重入锁，都会试图在执行后续代码前，得到临界区的锁，如果得不到，线程就会被挂起等待，直到占有了所需资源为止。

**2.无饥饿（Starvation-Free）**：如果线程之间是有优先级的，那么线程调度的时候总是会倾向于满足高优先级的线程。对于非公平的锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。但如果锁是公平的，满足先来后到，那么饥饿就不会产生，不管新来的线程优先级多高，要想获得资源，就必须乖乖排队。那么所有的线程都有机会执行。

**3.无障碍（Obstruction-Free）**：无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方被挂起。

属于乐观策略，认为线程执行之间不会发生冲突，而一但检测到冲突，就应该进行回滚。

然而当发生严重的冲突时，会导致所有的线程都在不断回滚自己的操作，无法顺利执行。

一种可行的无障碍实现可以依赖一个“一致性标记”来实现。线程在操作之前，先读取并保存这个标记，在操作完成后，再次读取，检查这个标记是否被更改过，如果两者是一致的，则说明资源访问没有冲突。如果不一致，则说明资源可能在操作过程中与其他写线程冲突，需要重试操作。而任何对资源有修改操作的线程，在修改数据前，都需要更新这个一致性标记，表示数据不再安全。

**4.无锁（Lock-Free）**：无锁的并行都是无障碍的。在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。

**5.无等待（Wait-Free）**：无锁只要求有一个线程可以在有限步内完成操作，而无等待则在无锁的基础上更进一步进行扩展。它要求所有的线程都必须在有限步内完成，这样就不会引起饥饿问题。

一种典型的无等待结构就是RCU（Read-Copy-Update）。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先取得原始数据的副本，接着只修改副本数据（这就是为什么读可以不加控制），修改完成后，在合适的时机回写数据。

